                    // Parece que el ejemplo en C usa una pila pero solo para ver por qué
                    // que tipo de estructura se está parseando.
                    // Usa convenciones de estandos en los que se peude estar parseando
                    // una lista o diccionario.
                    // Puedo usar un enum para los estados. Usar los mismos que el programa de c pero
                    // con nombres. De hecho puedo hacer la misma implementación.
                    // Lo bueno de esa pila es que funciona con un solo byte para el enum.
                    // La verdad que consume poquísima memoria.
                    // Es como la maquina de estados del parser en done hay subestados.
                    // Al final se podría incluso hacer el diagrama. Creo que
                    // para los compiladores se usaba algúndigrama para prepresentar la
                    // gramática. Lo que no estoy seguro es que es un token.
                    // Al final el bucle parsea los tokens pero tambín monta la gramática.
                    // De hecho la gramática es la otra máquina de esatdos.
                    // En realidad el lengauage tiene solo un elemento que es expresión,
                    // que es recursivo y termina en elementos integer y string.
                    // Bueno es un lenguage con un solo elemento que puede tener 4 tipos.

- Podría contar el número de items en la lista en vez de tener dos estados. Que el estado tengo un contador.                    
- Si hago lo del data provider para los tests, la estructura puede ser un strcut 
quepuede contener un caso (title, beencode, expected json) o un vector de este enum.
Para poder anidar los casos (agruparlos como están ahora)

- State -> 
    StackValue
    ParsingState
    
pub enum State {
    ParsingInteger,
    ParsingString(ParsingString),
    ParsingList(ParsingList),
    ParsingDictionary(ParsingDictionary),
}

pub enum ParsingState {
    Integer,
    String(ParsingString),
    List(ParsingList),
    Dictionary(ParsingDictionary),
}

- mover a mod stack los enums y el stack.
- extraer duplicados de empezar string porque voya meter un montón de duplicados para el segundo key-value pair.
- Y tambiénlas acciones que se hacen después de parsear los typs básicos integer o string de actualizar el estado.
- Podría contar el número de items en la lista en vez de tener dos estados. Que el estado tengo un contador. 
  Creo que se pueden simplificar los estados eliminando la diferencia entre primer y subsecuentes items en listas y diccionarios.
  EL elemento padre, puede contener un valor en el stack que sea cuantos elementos tiene (items or key-value pairs).
  Cuando se empieza a parsear un nuevo item, se mira en la pila cuantos elementos tiene el padre para saber si es el primero o no.
  Esto no lo hice así porque era un coñazo manipular el top de la pila. Pero cuando esté refactorizado a lo mejor no es tan coñazo
  porque se puede pregutar si el top de la pila es una lista y esta vacia o que devuelva el número de elementos de la pila si el top es una lista, etc.

  - HAcer un caso siple de diccionario por si fastidia todo el invento. Luego
  sigo con los casos de las listas y más casos. Pero mejor terminar este último
  tipo.
- Seguir con listas aninadas.
- Estaría bien poder ejecutar la batería de test contra otras implementaciones como la de C.
  Para eso si estaría bien tener una lista de casos (data provider para los test unitoarios).
  Para usar la misma lista para el test E2E del otro programa.


